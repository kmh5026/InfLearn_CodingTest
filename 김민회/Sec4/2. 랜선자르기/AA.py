
# 랜선자르기 (결정 알고리즘) *****

'''
# 결정 알고리즘의 특징 
: 특정 범위 안에 답이 있다 
: 중간 지점 / 좌한 / 우한 설정 >> 이분탐색 
'''

import sys 
sys.stdin = open('/Users/kimmh/Desktop/Algorithm/Sec4/2. 랜선자르기/in5.txt', 'rt') 

#--------------------------------------------------------------------------------# 
# 1. K개의 길이가 다른 랜선 갖고 있음 
# 2. N개의 길이가 같은 랜선을 만들고자 함 (남는 건 버림) (K는 N 이하) 
# 3. 랜선을 자를 때 손실되는 길이는 없다고 가정 / K개 랜선으로 N개 랜선을 만들 수 없는 경우는 없다 가정 
# 4. N개보다 많이 만드는 것도 N개를 만드는 것에 포함 
# 5. 만들 수 있는 랜선(N개)의 최대 길이를 구하는 프로그램 
# 
# 입력1) K, N (K는 1만 이하 자연수, N은 100만 이하 자연수) (N>=K)
# 입력2) K줄에 걸쳐 기존에 갖고 있는 각 랜선의 길이 
# 출력) 만들 수 있는 랜선(N개)의 최대 길이 
#--------------------------------------------------------------------------------# 

K, N = map(int, input().split()) 

# K개 기존 랜선 리스트 
lan = [] 

for _ in range(K): 
    lan.append(int(input())) 


# 새 랜선의 길이는 아무리 길어봤자 (남는거 없이 딱 떨어져봤자) 
largest = sum(lan) // N 


# K개의 랜선을 len 길이로 잘라붙인 후 랜선 갯수 (함수 안 만들어도 됨) 
def Count(len): 
    cnt = 0 
    for i in lan:
        cnt += (i//len) 
    return cnt 


### 결정알고리즘 ***** 

lt = 1                      # 좌한 초기화 
rt = largest                # 우한 초기화 

while lt <= rt:             # 좌한/우한이 만날 때까지 (최대길이 지점) 

    mid = (lt+rt)//2        # 중간 초기화 

    cnt = 0                 # K개의 랜선을 mid 길이로 잘라붙인 후 랜선 갯수 
    for i in lan:
        cnt += (i//mid) 

    if cnt >= N: 
        result = mid 
        lt = mid + 1 
    
    else: 
        rt = mid - 1 

print(result) 



